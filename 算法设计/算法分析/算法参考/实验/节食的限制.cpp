问/*题 B: 节食的限制
题目描述
Bessie像她的诸多姊妹一样，因为从Farmer John的草地吃了太多美味的草而长出了太多的赘肉。所以FJ将她置于一个及其严格的
节食计划之中。她每天不能吃多过H(5<=H<=45000)公斤的干草。Bessie只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了。
她有一个完整的N(1<=n<=50)捆可以给她当作晚餐的干草的清单。她自然想要尽量吃到更多的干草。很自然地，每捆干草只能被吃一次
（即使在列表中相同的重量可能出现2次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）。给定一个列表表示每捆干草
的重量Si(1<=Si<=H) ,求Bessie不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）

输入
第一行：两个由空格隔开的整数：H和N，第2到N+1行：第i +1行是一个单独的整数，表示第i捆干草的重量Si。

输出
一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的干草。

样例输入
56 4
15
19
20
21
样例输出
56
题意
在n个物品中任意选取，总重要尽量大且不超过h。

思路
典型的0-1背包题，不同的是重量和价值是一样的。

递归函数：

dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+w[i]);

*/
#include<iostream>
#include<stdio.h>
using namespace std;
int dp[55][45002];
int main()
{
    int h,n,w[55];
    scanf("%d %d",&h,&n);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d",&w[i]);
    }
    for(int i = 0; i <= h; i++)
        dp[0][i] = 0;
    for(int i = 1; i <= n; i++)
        dp[i][0] = 0;
    for(int i = 1; i <= n; i++)
    {
        int jMax = min(h,w[i]);
        for(int j = 1; j < jMax; j++)
            dp[i][j] = dp[i-1][j];
        for(int j = w[i]; j <= h; j++)
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]]+w[i]);
    }
    printf("%d\n",dp[n][h]);
    return 0;
}
