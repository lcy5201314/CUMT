/*问题 B: 汽水瓶
题目描述
有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”
答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，
这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。
如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？
输入
输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n=0表示输入结束，
你的程序不应当处理这一行。
输出
对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0
样例输入
3
10
81
0
样例输出
1
5
40
题意
一开始给你 n 个空瓶子，然后 3 个空瓶子能换一瓶汽水，问最多可以换多少瓶汽水喝。
注意，当你有 2 个空瓶子的时候，可以先借一瓶。我一开始看到题目没看到后面的就直接交 WA 了 QAQ
思路
因为老师要我讲这题，所以写详细点。
思路一：（常规思路）模拟
ans 存储这一轮完成后的结果，emp 存储这一轮完成后的空瓶数。
题目怎么来，我们就怎么写代码。模拟一下，用 tmp 存储这一轮喝的汽水的瓶数，则有：
ans += tmp;
emp = emp % 3 + tmp;
循环的条件是什么？答案很显然是 while(emp >= 2)。
emp == 2 的时候怎么处理？答案是先借一瓶，即 emp++。
最终，输出 ans 即可。
思路二：递归函数
写一个参数是当前空瓶的数量 n 的递归函数，我们就把它叫做 f() 函数吧，考虑三种情况：
如果空瓶数为 2 以下（0 或 1），则换不了瓶子，返回 0，结束递归；
如果空瓶数为 2，那么可换 1 瓶，返回 1，结束递归；
其他情况：本轮可以喝 n/3（除法向下取整），那么本轮之后的空瓶数就是 n/3 + n % 3。
那么f()函数的代码就只有三行：
if(n < 2) return 0;
if(n == 2) return 1;
return n/3 + f(n/3 + n%3);（因为刨除掉了其他情况，所以最后一行可不写if语句）
主函数输出一下f(n)即可。
注意：本题n最多取到100，而且子问题规模下降得很快，所以可以用递归直接写。如果规模很大，后台测试数据量很大，
抑或是子问题规模下降得不快的话，可以化递归为递推，也就是开一个数组存储结果，这样避免了重复运算和爆栈。
思路三：找规律
当然了，以上说的都不是最简单的方法。还有一种方法比上面的代码简单多了，在 main() 函数中除去return 0; 
后二至三行代码就能搞定。怎么写呢？先找找规律吧！
先看看样例：
输入 3，输出 1
输入 10，输出 5
输入 81，输出 40
我们其实可以看出输入输出间存在着一种微妙的关系：
输入除 2 向下取整的结果就是输出。
那我们可以自己验证下猜想：
输入 1，输出 0。
输入 2，输出 1。
输入 3，输出 1。
输入 4，输出 2。
输入 5，输出 2。
……
为什么呢？因为有借这种操作。从题目看出，2 个空瓶就可以换 1 瓶汽水，那我们每次拿 2 个空瓶就可以换 1 瓶汽水呗，
而且这样还有个好处：每次换不会产生新的空瓶。
代码1(模拟)
#include<iostream>
#include<stdio.h>
using  namespace std;
int main()
{
    int n;
    while(~scanf("%d",&n) && n)
    {
        int ans = 0,emp = n,tmp;
        while(emp >= 2)
        {
            if(emp == 2) emp++;
            tmp = emp/3;
            ans += tmp;
            emp = emp%3+tmp;
        }
        printf("%d\n",ans);
    }
    return 0;
}*/
代码2(将模拟封装成一个递归函数)
#include<iostream>
#include<stdio.h>
using  namespace std;
int f(int n)
{
    //如果空瓶数为2以下（0或1），则换不了瓶子，返回0，结束递归
    if(n < 2) return 0;
    //如果空瓶数为2，那么可换1瓶，返回1，结束递归
    if(n == 2) return 1;
    return n/3 + f(n/3 + n%3);
}
int main()
{
    int n;
    while(~scanf("%d",&n) && n)
    {
        printf("%d\n",f(n));
    }
    return 0;
}
/*
代码3(找规律)
#include<iostream>
#include<stdio.h>
using  namespace std;
int main()
{
    int n;
    while(~scanf("%d",&n) && n)
    {
        printf("%d\n",n/2);
    }
    return 0;
}*/
