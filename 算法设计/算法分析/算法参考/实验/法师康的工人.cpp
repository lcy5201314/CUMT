/*问题 D: 法师康的工人
题目描述
三个法师康的工人每天早上6点到工厂开始到三条产品生产线上组装桔子手机。第一个工人在200时刻开始（从6点开始计时，
以秒作为单位）在生产线上开始生产，一直到1000时刻。第二个工人，在700时刻开始，在1100时刻结束。第三个工人从1500时刻工作
到2100时刻。期间最长至少有一个工人在生产线上工作的连续时间为900秒（从200时刻到1100时刻），而最长的无人生产的连续时间
（从生产开始到生产结束）为400时刻（1100时刻到1500时刻）。

你的任务是用一个程序衡量N个工人在N条产品线上的工作时间列表（1≤N≤5000，以秒为单位）。

・最长的至少有一个工人在工作的时间段

・最长的无人工作的时间段（从有人工作开始计）

输入
输入第1行为一个整数N，第2-N+1行每行包括两个均小于1000000的非负整数数据，表示其中一个工人的生产开始时间与结束时间。

输出
输出为一行，用空格分隔开两个我们所求的数。

样例输入
3
200 1000
700 1100
1500 2100
样例输出
900 400
题意
有n个线段区间。给出左界l和右界r，求最长的至少被一条线段覆盖的连续区间长度和最长的没被线段覆盖的区间长度。

思路
ans1指最长的至少被一条线段覆盖的连续区间长度。

ans2值最长的没被线段覆盖的区间长度。

输入后，先按开始时间从小到大排序。

可以把多个连续的区间（相交或相切）看成一个区间，如何实现呢？

a[j].e = max(a[i].e,a[j].e);

a[j]为上一个连续区间。这时候如果连续区间>ans1那么更新下ans1。

这样遇到不连续的且断裂的长度>ans2就更新下ans2，再把当前区间赋给j（成为上一个区间）。

代码*/
#include<iostream>
#include<algorithm>
#include<stdio.h>
using namespace std;
const int maxn = 5005;
struct node
{
    int b,e;
    bool operator < (const node& c) const
    {
        return b < c.b;
    }
}a[maxn];
int main()
{
    int n,ans1,ans2;
    scanf("%d",&n);
    for(int i = 0; i < n; i++)
    {
        scanf("%d %d",&a[i].b,&a[i].e);
    }
    sort(a,a+n);
    ans1 = a[0].e - a[0].b;
    ans2 = 0;
    int j = 0;
    for(int i = 1; i < n; i++)
    {
        if(a[i].b <= a[j].e)    //如果交叉或相切
        {
            a[j].e = max(a[i].e,a[j].e);
            ans1 = max(ans1,a[j].e-a[j].b);
        }
        else
        {
            ans2 = max(ans2,a[i].b-a[j].e);
            j = i;
        }
    }
    printf("%d %d\n",ans1,ans2);
    return 0;
}
