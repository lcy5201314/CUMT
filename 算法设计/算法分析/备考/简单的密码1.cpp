/*它的长度固定为n（n<=30）并且每一位只能由数字0或者数字1组成，但是有一个特殊的要求：一个密码序列中至少要有连续的3个0出现才可以，否则就是无效的。现在给定你密码序列的长度n，你的任务是计算长度为n的序列能产生多少种不同的并且有效的密码？
输入
输入包含多组数据，每组数据只有一个正整数n（1<=n<=30）代表密码序列的长度，单独占一行。
输出
对每组数据，输出一个整数，代表长度为n的序列能产生的不同密码的种类数。
样例输入
4
5
6
样例输出
3
8
20*/
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	int dp[32];
	dp[0] = 0;
	dp[1] = 0;
	dp[2] = 0;
	dp[3] = 1;//当有三个数时最多只能组成一组密码即000 
	while (cin >> n)
	{
		for (int i = 4; i <= n; i++)
		{
			dp[i]=2*dp[i-1]+pow(2,i-4)-dp[i-4];//递推式   pow(2,i-4)等价于(1<<(i-4))
			//2*dp[i-1]：上一步如果有000出现，那这一步可以为0，也可以为1
			//pow(2,i-4)-dp[i-4]：上一步为100的时候，这三位（i-1位、i-2位、i-3位）已经定死了，
			//那我们只要考虑到i-4位时不符合条件的数量，即总的减去符合条件的（2^(i-4)-dp[i-4]） 
		}
		cout << dp[n] << endl;
		
	}
	return 0;
}

