# 问题 A: 凯撒加密法

时间限制: 1 Sec 

内存限制: 128 MB


## 题目描述

​    凯撒加密法，或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。
​    例如，当偏移量是左移3的时候：
明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ
密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC
使用时，加密者查找明文字母表中需要加密的消息中的每一个字母所在位置，并且写下密文字母表中对应的字母。需要解密的人则根据事先已知的密钥反过来操作，得到原来的明文。例如：
​    明文：THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
​    密文：WKH TXLFN EURZQ IRA MXPSV RYHU WKH ODCB GRJ
​    现在给定你一个字符串S（长度不会超过1000000）和一个整数k（-1000000000<=k<=1000000000），分别代表接受者收到的密文和在加密该密文时向后的偏移量，你的任务是计算出原来的明文
​    注意：只有字母在加密时才会发生偏移，其它字符保持不变

## 输入

​    输入包含多组数据，其中第一行为数据组数T（T<=10）
​    每组数据第一行为一个字符串S，由数字、字母以及常见字符组成（不含空格），第二行为一个整数k代表加密时向后的偏移量（|S|<=1000000,-1000000000<=k<=1000000000）

## 输出

​    对每组数据，输出一行字符串，代表输入中的密文对应的明文。

## 样例输入

```
1
DEFGHIJKLMNOPQRSTUVWXYZABC
3
```

## 样例输出

```
ABCDEFGHIJKLMNOPQRSTUVWXYZ
```

## 思路



## 代码

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t;
	cin >> t;
	while(t--){
		string str;
		cin >> str;
		long long n;
		cin >> n;
		n = n % 26;
		for(int i=0;i<=str.size();i++){
			if(str[i] >= 'A' && str[i] <= 'Z'){
				str[i] = 'A' + (str[i] - 'A' + 26 - n) % 26;
			}
			if(str[i] >= 'a' && str[i] <= 'z'){
				str[i] = 'a' + (str[i] - 'a' + 26 - n) % 26;
			}
		}
		cout << str << endl;
	}
}
```

2021中国矿业大学程序设计学科竞赛!



# 问题 B: Vigenère 密码时间

限制: 1 Sec 

内存限制: 128 MB


## 题目描述

16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法——Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北战争中为南军所广泛使用。

在密码学中，我们称需要加密的信息为明文，用 M*M* 表示；称加密后的信息为密文，用 C*C* 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 k*k*。 在 Vigenère 密码中，密钥 k*k* 是一个字母串，*k*=*k1k2...kn*。当明文 M = m1m2...mn 时，得到的密文 C = c1c2...cn ，其中 ci = mi ® ki，运算 ® 的规则如下表所示：

![img](%E5%AE%9E%E9%AA%8C4.assets/20180910173109_58996.png)



Vigenère 加密在操作时需要注意：

1. ® 运算忽略参与运算的字母的大小写，并保持字母在明文 M*M* 中的大小写形式；
2. 当明文 M*M* 的长度大于密钥 k*k* 的长度时，将密钥 k*k* 重复使用。 例如，明文 M=*M*=Helloworld，密钥 k=*k*=abc时，密文 C=*C*=Hfnlpyosnd。

![img](%E5%AE%9E%E9%AA%8C4.assets/20180910173353_81009.png)

## 输入

第一行为一个字符串，表示密钥 k*k*，长度不超过 100100，其中仅包含大小写字母。

第二行为一个字符串，表示经加密后的密文，长度不超过 10001000，其中仅包含大小写字母。

## 输出

输出共 11 行，一个字符串，表示输入密钥和密文所对应的明文。

## 样例输入

```
CompleteVictory
Yvqgpxaimmklongnzfwpvxmniytm
```

## 样例输出

```
Wherethereisawillthereisaway
```

## 思路



## 代码

```c++
#include<bits/stdc++.h>
using namespace std;

int main(){
	string strc,strm,strk;
	cin >> strk >> strm;
	for(int i=0;i<strk.size();i++){
		if(strk[i] >= 'A' && strk[i] <= 'Z'){
			strk[i] = 'a' + strk[i] - 'A';
		}
	}
	for(int i=0;i<=strm.size();i++){
		if(strm[i] >= 'A' && strm[i] <= 'Z'){
			strm[i] = 'A' + (strm[i] - 'A' - (strk[i % strk.size()] - 'a')+26) % 26;
		}
		if(strm[i] >= 'a' && strm[i] <= 'z'){
			strm[i] = 'a' + (strm[i] - 'a' - (strk[i % strk.size()] - 'a')+26) % 26;
		}
	}
	cout << strm << endl;
	return 0;
}
```

# 问题 C: 简单的密码

时间限制: 1 Sec 

内存限制: 128 MB


## 题目描述

密码是按特定法则编成，用以对通信双方的信息进行明密变换的符号。密码是隐蔽了真实内容的符号序列。其实就是把用公开的、标准的信息编码表示的信息通过一种变换手段，将其变为除通信双方以外其他人所不能读懂的信息编码，这种独特的信息编码就是密码。
现在我们定义一种非常简单的密码，它的长度固定为n（n<=30）并且每一位只能由数字0或者数字1组成，但是有一个特殊的要求：一个密码序列中至少要有连续的3个0出现才可以，否则就是无效的。现在给定你密码序列的长度n，你的任务是计算长度为n的序列能产生多少种不同的并且有效的密码？

## 输入

输入包含多组数据，每组数据只有一个正整数n（1<=n<=30）代表密码序列的长度，单独占一行。

## 输出

对每组数据，输出一个整数，代表长度为n的序列能产生的不同密码的种类数。

## 样例输入

```
4
5
6
```

## 样例输出

```
3
8
20
```

## 思路

这没思路，感觉不会考

参考大佬吧https://comydream.github.io/2018/10/20/algorithm-meets-crypt/

## 代码

### 思路

这题真的让我想了好久！

一直没想到合适的方法！

#### 思路：dfs

当前面已经出现连续3个0了，那后面就随便填写，每一位都可以填0或者1两种，当前层数为`d`，那么对于比`d`大的`i`，`dp[i] += (1<<(i-d));`。

当你写了一个程序TLE了，但是你确定结果就是对的，不妨把答案打成一个表，输入了直接查表输出就好了（而且这题`n`最大30），时间复杂度O(1)！

#### 思路：递推

先给出递推式：`f[i] = 2*f[i-1]+(1<<(i-4))-f[i-4];`

为什么呢？

1. `2*f[i-1]`上一步如果已经有连续3个`0`了，那这一步可`0`可`1`；
2. `(1<<(i-4))-f[i-4]`什么时候会有除上一种情况之外的解呢？答案是当上一步最后3位为`100`的时候，这三位（`i-1`位、`i-2`位、`i-3`位）已经定死了，那我们只要考虑到`i-4`位时不符合条件的数量，即总的减去符合条件的（2i-4-`f[i-4]`）。

#### 思路：dp

其实我觉得这是最简单想到的思路。

开一个二维数组`dp[i][j]`。

首先，定义**非解情况**：前`i`位中不存在连续3个0。

`dp[i][0]`代表最后一位为1的非解情况。

`dp[i][1]`代表最后一位为0（最后两位为10）的非解情况。

`dp[i][2]`代表最后两位为00（最后三位为100）的非解情况。

`dp[i][3]`代表解情况。

则可由`i-1`推`i`，有：

```
dp[i][0] = dp[i-1][0]+dp[i-1][1]+dp[i-1][2];
```

- 所有上一步非解情况后面补1都可以得到

```
dp[i][1] = dp[i-1][0];
```

- 上一步非解且最后一位是1后面补0得到

```
dp[i][2] = dp[i-1][1];
```

- 上一步非解且最后一位是0（最后两位为10）后面补0得到

```
dp[i][3] = dp[i-1][2]+dp[i-1][3]*2;
```

- 上一步非解且最后两位是00（最后三位为100）或者上一步就是解后面补0或1得到

主函数每输入一个`n`，输出`dp[n][3]`。

### 代码(TLE)

```c++
#include<iostream>
#include<stdio.h>
#include<string.h>
using namespace std;
int ans;
int dp[32];
void dfs(int pre,bool ok,int d)
{
    if(ok)
    {
        for(int i = d; i <= 30; i++)
        {
            dp[i] += (1<<(i-d));
        }
        return;
    }
    if(d == 30) return;
    dfs(pre+1,ok||(pre+1 >= 3)?true:false,d+1);
    dfs(0,ok,d+1);
}
int main()
{
    int n;
    dfs(0,false,0);
    while(~scanf("%d",&n))
    {
        printf("%d\n",dp[n]);
    }
    return 0;
}
代码(TLE的结果打一张表存数组里)
#include<iostream>
#include<stdio.h>
using namespace std;
int dp[32] = {0,0,0,1,3,8,20,47,107,238,520,1121,2391,5056,10616,22159,46023,95182,196132,402873,825259,1686408,3438828,6999071,14221459,28853662,58462800,118315137,239186031,483072832,974791728};
int main()
{
    int n;
    while(~scanf("%d",&n))
    {
        printf("%d\n",dp[n]);
    }
    return 0;
}
```

### 代码(TLE的结果打一张表存数组里)

```c++
#include<iostream>
#include<stdio.h>
using namespace std;
int dp[32] = {0,0,0,1,3,8,20,47,107,238,520,1121,2391,5056,10616,22159,46023,95182,196132,402873,825259,1686408,3438828,6999071,14221459,28853662,58462800,118315137,239186031,483072832,974791728};
int main()
{
    int n;
    while(~scanf("%d",&n))
    {
        printf("%d\n",dp[n]);
    }
    return 0;
}
```

### 代码(递推，找规律)

```c++
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<math.h>
using namespace std;
int f[32] = {0,0,0,1};
int main()
{
    for(int i = 4; i <= 30; i++)
    {
        f[i] = 2*f[i-1]+(1<<(i-4))-f[i-4];
    }
    int n;
    while(~scanf("%d",&n))
    {
        printf("%d\n",f[n]);
    }
    return 0;
}
```

### 代码(dp)

```c++
#include<iostream>
#include<stdio.h>
using namespace std;
int dp[33][4];
void init()
{
    dp[1][0] = 1;   //非解且最后一位是1
    dp[1][1] = 1;   //非解且最后一位是0
    dp[1][2] = 0;   //非解且最后两位是0
    dp[1][3] = 0;   //解
    for(int i = 2; i <= 30; i++)
    {
        dp[i][0] = dp[i-1][0]+dp[i-1][1]+dp[i-1][2];
        dp[i][1] = dp[i-1][0];
        dp[i][2] = dp[i-1][1];
        dp[i][3] = dp[i-1][2]+dp[i-1][3]*2;
    }
}
int main()
{
    init();
    int n;
    while(~scanf("%d",&n))
    {
        printf("%d\n",dp[n][3]);
    }
    return 0;
}
```





# 问题 D: 有趣的素数

时间限制: 2 Sec 

内存限制: 128 MB

## 题目描述

素数被广泛地应用于密码学中，所谓的公钥就是将想要传递的信息在编码时加入砠数，编码之后传给收信人，任何人收到此信息之后，若没有此收信人所拥有的秘钥，则在解密的过程中将会因为分解质因数过久而无法破解信息，可见素数在密码学中的重要性。
现在给你n（2<=n<=16）个正整数1,2,3...n，你的任务是把这n个正整数组成一个环，使得任意相邻的两个整数之和为一个素数，输出有多少种合法方案。

## 输入

多组输入数据，每组数据只有一个正整数n（2<=n<=16）代表有n个正整数 1,2,3...n

## 输出

对每组数据，输出一个整数，代表有多少种不同的可行方案数。

## 样例输入

```
6
8
```

## 样例输出

```
2
4
```

## 提示




对于输入样例中的6，有以下2种合法方案（首尾相连构成一个环）

```
1 4 3 2 5 6
1 6 5 2 3 4
```

对于输入样例中的8，有以下4种合法方案（首尾相连构成一个环）


```
1 2 3 8 5 6 7 4
1 2 5 8 3 4 7 6
1 4 7 6 5 8 3 2
1 6 7 4 3 8 5 2
```

