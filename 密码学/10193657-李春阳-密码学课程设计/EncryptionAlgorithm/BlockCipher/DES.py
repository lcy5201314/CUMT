"""
@Time    : 2021/11/23
@Author  : LowlyLi
@Version : 1.0
@File    : HillCipher.py
@Introduce: HillCipher 希尔加密
"""
import re

######################################################################################
# 这里是一堆DES用的置换盒
#######################################################################################

# 一开始的ip置换
IP_table = [58, 50, 42, 34, 26, 18, 10, 2,
            60, 52, 44, 36, 28, 20, 12, 4,
            62, 54, 46, 38, 30, 22, 14, 6,
            64, 56, 48, 40, 32, 24, 16, 8,
            57, 49, 41, 33, 25, 17, 9, 1,
            59, 51, 43, 35, 27, 19, 11, 3,
            61, 53, 45, 37, 29, 21, 13, 5,
            63, 55, 47, 39, 31, 23, 15, 7]

# IP置换逆盒
IP_re_table = [40, 8, 48, 16, 56, 24, 64, 32, 39,
               7, 47, 15, 55, 23, 63, 31, 38, 6,
               46, 14, 54, 22, 62, 30, 37, 5, 45,
               13, 53, 21, 61, 29, 36, 4, 44, 12,
               52, 20, 60, 28, 35, 3, 43, 11, 51,
               19, 59, 27, 34, 2, 42, 10, 50, 18,
               58, 26, 33, 1, 41, 9, 49, 17, 57, 25]

# E盒置换盒
E = [32, 1, 2, 3, 4, 5, 4, 5,
     6, 7, 8, 9, 8, 9, 10, 11,
     12, 13, 12, 13, 14, 15, 16, 17,
     16, 17, 18, 19, 20, 21, 20, 21,
     22, 23, 24, 25, 24, 25, 26, 27,
     28, 29, 28, 29, 30, 31, 32, 1]

# 置换运算P盒
P = [16, 7, 20, 21, 29, 12, 28, 17,
     1, 15, 23, 26, 5, 18, 31, 10,
     2, 8, 24, 14, 32, 27, 3, 9,
     19, 13, 30, 6, 22, 11, 4, 25]

# 8个S代换盒
S = [
    # S1
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7,
     0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8,
     4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0,
     15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],
    # S2
    [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10,
     3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5,
     0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15,
     13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],
    # S3
    [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8,
     13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1,
     13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7,
     1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],
    # S4
    [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15,
     13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9,
     10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4,
     3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],
    # S5
    [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9,
     14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6,
     4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14,
     11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],
    # S6
    [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11,
     10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8,
     9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6,
     4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],
    # S7
    [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1,
     13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6,
     1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2,
     6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],
    # S8
    [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7,
     1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2,
     7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8,
     2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],

]

# key
# 密钥编排
PC_1 = [57, 49, 41, 33, 25, 17, 9,
        1, 58, 50, 42, 34, 26, 18,
        10, 2, 59, 51, 43, 35, 27,
        19, 11, 3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
        7, 62, 54, 46, 38, 30, 22,
        14, 6, 61, 53, 45, 37, 29,
        21, 13, 5, 28, 20, 12, 4]

PC_2 = [14, 17, 11, 24,  1,  5,  3, 28,
      15,  6, 21, 10, 23, 19, 12,  4,
      26,  8, 16,  7, 27, 20, 13,  2,
      41, 52, 31, 37, 47, 55, 30, 40,
      51, 45, 33, 48, 44, 49, 39, 56,
      34, 53, 46, 42, 50, 36, 29, 32]

# 秘钥左移的位数
SHIFT = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]


######################################################################################
#            下面是正常的函数
#####################################################################################

# 二进制转字符串
def bin2str(bin_str):
    res = ""
    tmp = re.findall(r'.{8}', bin_str)  # 每8位表示一个字符
    for i in tmp:
        res += chr(int(i, 2))
    return res



# 将明文转化为二进制
def str2bin(message):
    res = ''
    for i in message:
        tmp = bin(ord(i))[2:]  # 将每个字符转化成二进制
        tmp = str('0' * (8 - len(tmp))) + tmp  # 补齐8位
        res += tmp
    if len(res) % 64 != 0:
        count = 64 - len(res) % 64  # 不够64位补充0
    else:
        count = 0
    res += '0' * count
    return res

# 将密钥转化为二进制
def key2bin(key):
    res = ''
    for i in key:
        tmp = bin(ord(i))[2:]  # 将每个字符转化成二进制
        tmp = str('0' * (8 - len(tmp))) + tmp  # 补齐8位
        res += tmp
    if len(res) < 64:
        count = 64 - len(res) % 64  # 不够64位补充0
        res += '0' * count
    else:
        res = res[:64]
    return res

# 字符串转16进制
def str2hex(text):
    res = ''
    for ch in text:
        tmp = hex(ord(ch))[2:].zfill(2)
        res += tmp
    return res
# 16进制转字符串
def hex2str(hex_text):
    res = ''
    tmp = re.findall(r'.{2}', hex_text)
    for i in tmp:
        res += chr(int('0x' + i, 16))
    return res






class DES:


    # IP盒处理
    def ip_change(slef, str_bin):
        """
        IP盒，这里就是把二进制的持续打乱
        :param str_bin: 二进制字符串
        :return:
        """
        res = ''
        for i in IP_table:
            res += str_bin[i - 1]
        return res

    # 生成子密钥
    def gen_key(slef, bin_key):
        """
        生成扩展的子密钥
        :param bin_key: 二进制字符串
        :return:
        """
        key_list = []
        # 秘钥的PC-1置换
        key1 = slef.change_key1(bin_key)
        # 分成2部分，各28位
        key_C0 = key1[0:28]
        key_D0 = key1[28:]
        # shift左移位数
        for i in SHIFT:
            # 左移操作
            key_c = key_C0[i:] + key_C0[:i]
            key_d = key_D0[i:] + key_D0[:i]
            # 秘钥的PC-2置换
            key_output = slef.change_key2(key_c + key_d)
            # 得到一个密钥
            key_list.append(key_output)

        return key_list

    # 秘钥的PC-1置换
    def change_key1(slef, my_key):
        """
        秘钥的PC-1置换，和ip盒差不多
        :param my_key: 密钥
        :return:
        """
        # PC_1盒上的元素表示位置    只循环64次
        res = ""
        for i in PC_1:
            # 将密钥按照PC_1的位置顺序排列，
            res += my_key[i - 1]
        return res

    # 秘钥的PC-2置换
    def change_key2(slef, my_key):
        """
        秘钥的PC-2置换，类似
        :param my_key:
        :return:
        """
        res = ""
        for i in PC_2:
            res += my_key[i - 1]
        return res


    # E盒置换
    def e_change(slef, str_left):
        """
        F变换首先进行E盒置换，和上面一样,这里是扩展
        :param str_left:
        :return:
        """
        res = ""
        for i in E:
            res += str_left[i - 1]
        return res

    def xor_change(slef, str1, str2):
        """
        异或操作
        :param str1:
        :param str2:
        :return:
        """
        res = ""
        for i in range(0, len(str1)):
            # 进行xor操作
            xor_res = int(str1[i], 10) ^ int(str2[i], 10)
            if xor_res == 1:
                res += '1'
            if xor_res == 0:
                res += '0'
        return res


    # S盒代换盒
    def s_change(slef, my_str):
        """
        S盒代换盒，8个S盒，6进4出，实现非线性
        :param my_str:
        :return:
        """
        res = ""
        c = 0
        # 步长为6   表示分6为一组  8组
        for i in range(0, len(my_str), 6):
            # 第i个分组
            now_str = my_str[i:i + 6]
            # 第r行
            row = int(now_str[0] + now_str[5], 2)
            # 第c列
            col = int(now_str[1:5], 2)
            # 第几个s盒的第row*16+col个位置的元素
            num = bin(S[c][row * 16 + col])[2:]
            # 补全4位
            for gz in range(0, 4 - len(num)):
                num = '0' + num
            res += num
            c += 1

        return res

    def p_change(slef, bin_str):
        """
        P盒置换操作
        :param bin_str:
        :return:
        """
        res = ""
        for i in P:
            res += bin_str[i - 1]
        return res

    def f(slef, str_left, key):
        """
        F变换，这里主要的非线性加密主体
        :param str_left:
        :param key:
        :return:
        """
        # E扩展置换
        e_change_output = slef.e_change(str_left)
        # 将48位结果与子密钥Ki进行异或（xor）
        xor_output = slef.xor_change(e_change_output, key)
        # S盒代换
        s_change_output = slef.s_change(xor_output)
        # P盒置换
        res = slef.p_change(s_change_output)

        return res

    # IP逆盒处理
    def ip_re_change(slef, bin_str):
        """
        IP盒的逆操作
        :param bin_str:
        :return:
        """
        res = ""
        for i in IP_re_table:
            res += bin_str[i - 1]
        return res

    # 加密
    def encrypt(slef, bin_m, bin_key):
        # IP置换
        str_bin = slef.ip_change(bin_m)
        # 生成16个子密钥
        key_lst = slef.gen_key(bin_key)
        # 分为左右32位
        str_left = str_bin[:32]
        str_right = str_bin[32:]
        # 先循环15次 因为最后一次不需要不用换位
        for j in range(15):
            f_res = slef.f(str_right, key_lst[j])
            str_left = slef.xor_change(f_res, str_left)
            temp_str = str_right
            str_right = str_left
            str_left = temp_str

        # 第16次
        f_res = slef.f(str_right, key_lst[15])
        str_left = slef.xor_change(str_left, f_res)
        # ip的逆
        fin_str = slef.ip_re_change(str_left + str_right)

        return fin_str



    # 解密
    def decrypt(slef, bin_c, bin_key):  # 解密和加密的步骤差不多，但要注意解密时密钥是倒过来的 ，第一个的时候左右不交换
        # IP置换
        str_bin = slef.ip_change(bin_c)
        # 生成16个子密钥
        key_lst = slef.gen_key(bin_key)
        # 分为左右32位
        str_left = str_bin[:32]
        str_right = str_bin[32:]
        # 先循环15次 因为最后一次不需要不用换位
        for _j in range(1, 16):
            # 解密的时候秘钥反过来的
            j = 16 - _j
            f_res = slef.f(str_right, key_lst[j])
            str_left = slef.xor_change(f_res, str_left)
            temp_str = str_right
            str_right = str_left
            str_left = temp_str

        f_res = slef.f(str_right, key_lst[0])
        str_left = slef.xor_change(str_left, f_res)
        # ip的逆
        fin_str = slef.ip_re_change(str_left + str_right)

        return fin_str


class DESCipher:

    def Encrypt(m, k):
        des = DES()
        bin_str = str2bin(m)
        # print(bin_str)
        bin_key = key2bin(k)
        bin_str_list = re.findall(r'.{64}', bin_str)
        result = ""
        # print(bin_str_list)
        for temp in bin_str_list:
            ans = des.encrypt(temp,bin_key)
            result += ans
        # print(result)
        Ciphertext = str2hex(bin2str(result))
        return  Ciphertext



    def Decrypt(c, k):
        des = DES()
        bin_str = str2bin(hex2str(c))
        bin_key = key2bin(k)
        bin_str_list = re.findall(r'.{64}', bin_str)
        result = ""
        for temp in bin_str_list:
            ans = des.decrypt(temp,bin_key)
            result += ans
        Plaintext = bin2str(result)
        return Plaintext


    def test():
        while True:
            print("*******************欢迎来到DES加密！！！*******************")
            op = input("请选择模式?\n[0]退出 [1]加密 [2]解密 \n").upper()

            if op[0] == "0":
                break

            elif op[0] == "1":
                s = input("请输入加密的明文:\n")
                k = input("请输入加密的密钥:\n")
                if (s == "" or  k == ""):
                    print("输入错误，请重新输入")
                    continue
                print(8*"*"+"  DES加密：  "+8*"*")
                Encryption = DESCipher.Encrypt(s,k)
                print("加密后的密文是:\n")
                print(Encryption)

            elif op[0] == "2":
                s = input("请输入解密的密文:\n")
                k = input("请输入解密的密钥:\n")
                if(s == "" or k == ""):
                    print("输入错误，请重新输入")
                    continue
                print(8*"*"+"  DES解密  "+8*"*")
                Decryption = DESCipher.Decrypt(s,k)
                print("解密后的明文是:\n" + Decryption)


            else:
                print("输入错误，请重新输入")
                continue



if __name__ == '__main__':
    # des = DES()
    DESCipher.test()
    # c1 = "W£\x93^¡\x81èÌ@ïs\x81SP1Vü\x9c1ï¸mB¹nªüI|\xa0JoRÇ\x0eÞé\x96)T8À^sÛuÆch´&-©Áf\\"
    # c = "0x57a3935ea181e8cc40ef738153503156fc9c31efb86d42b96eaafc497ca04a6f52c70edee996295438c05e73db75c66368b4262da9c1665c"
    # bin_str = bin(int(c, 16))
    # print(bin_str)
    # print(str2bin(c1))



"""
    JAsia can see it, but everyone's visibility is on time
    
    ('0x57a3935ea181e8cc40ef738153503156fc9c31efb86d42b96eaafc497ca04a6f52c70edee996295438c05e73db75c66368b4262da9c1665c', 'W£\x93^¡\x81èÌ@ïs\x81SP1Vü\x9c1ï¸mB¹nªüI|\xa0JoRÇ\x0eÞé\x96)T8À^sÛuÆch´&-©Áf\\')
    
    W£^¡èÌ@ïsSP1Vü1ï¸mB¹nªüI| JoRÇÞé)T8À^sÛuÆch´&-©Áf\


0101011110100011100100110101111010100001100000011110100011001100010000001110111101110011100000010101001101010000001100010101011011111100100111000011000111101111101110000110110101000010101110010110111010101010111111000100100101111100101000000100101001101111010100101100011100001110110111101110100110010110001010010101010000111000110000000101111001110011110110110111010111000110011000111000011000000010011100000110111010111011110010001101001000010001
0100101001000001011100110110100101100001001000000110001101100001011011100010000001110011011001010110010100100000011010010111010000101100001000000110001001110101011101000010000001100101011101100110010101110010011110010110111101101110011001010010011101110011001000000111011001101001011100110110100101100010011010010110110001101001011101000111100100100000011010010111001100100000011011110110111000100000011101000110100101101101011001010000000000000000

['0100101001000001011100110110100101100001001000000110001101100001', '0110111000100000011100110110010101100101001000000110100101110100', '0010110000100000011000100111010101110100001000000110010101110110', '0110010101110010011110010110111101101110011001010010011101110011', '0010000001110110011010010111001101101001011000100110100101101100', '0110100101110100011110010010000001101001011100110010000001101111', '0110111000100000011101000110100101101101011001010000000000000000']
['0100101001000001011100110110100101100001001000000110001101100001', '0110111000100000011100110110010101100101001000000110100101110100', '0010110000100000011000100111010101110100001000000110010101110110', '0110010101110010011110010110111101101110011001010010011101110011', '0010000001110110011010010111001101101001011000100110100101101100', '0110100101110100011110010010000001101001011100110010000001101111', '0110111000100000011101000110100101101101011001010000000000000000']

0101011110100011100100110101111010100001100000011110100011001100010000001110111101110011100000010101001101010000001100010101011011111100100111000011000111101111101110000110110101000010101110010110111010101010111111000100100101111100101000000100101001101111010100101100011100001110110111101110100110010110001010010101010000111000110000000101111001110011110110110111010111000110011000110110100010110100001001100010110110101001110000010110011001011100  
1111001010011001100110101010110111110101010111101101001011101001100101101010000111101111111101000000101100101101001110000001110010110001010101110000010000000001010110101110010010111101101010111110011011100101010111010101110000000000011111101101000100001110000010100001011010001100010100111011001000001011010111111010101011111011001101111011010010101110000011110010001011111001011011100100001111101111000101000100101011100100101001101110010000100111

0b101011110100011100100110101111010100001100000011110100011001100010000001110111101110011100000010101001101010000001100010101011011111100100111000011000111101111101110000110110101000010101110010110111010101010111111000100100101111100101000000100101001101111010100101100011100001110110111101110100110010110001010010101010000111000110000000101111001110011110110110111010111000110011000110110100010110100001001100010110110101001110000010110011001011100
0101011110100011100100110101111010100001100000011110100011001100010000001110111101110011100000010101001101010000001100010101011011111100100111000011000111101111101110000110110101000010101110010110111010101010111111000100100101111100101000000100101001101111010100101100011100001110110111101110100110010110001010010101010000111000110000000101111001110011110110110111010111000110011000110110100010110100001001100010110110101001110000010110011001011100

"""